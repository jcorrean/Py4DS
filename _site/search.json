[
  {
    "objectID": "Py4DS.html",
    "href": "Py4DS.html",
    "title": "Analítica de Proyectos",
    "section": "",
    "text": "Hay varias razones que nos obligan a considerar otras opciones más allá de Excel y de Microsoft Project que suelen ser las herramientas más populares para la gestión de proyectos.\n\nExcel es limitado a la hora abrir archivos con datos que están en el orden de los millones de filas o columnas.\nMicrosoft Project es un software licenciado (no libre) orientado al control de proyectos y no nos permite saber los pequeños cambios que pueden ocurrir en el transcurso de cualquier proyecto.\nNi Excel ni Project son útiles para analizar “datos no estructurados” tales como colecciones de documentos, fotos, videos, o audios. En cambio los datos no estructurados son analizables con Python y R de una forma más ágil.\nEl análisis de datos no estructurados es la base fundamental de herramientas como el aprendizaje automático (conocido en inglés como Machine Learning). Veamos algunas funcionalidades básicas en las llamadas ciencias de datos para entender cómo funciona Python. Una cruda realidad es que las personas encargadas de recolectar datos no son especialistas en estadística y por ello no suelen guardar los datos de una manera que sean directamente usables para fines analíticos. Parte de lo que veremos en las próximas subsecciones está tomado del libro de texto de Hathaway y Larson (2021) quienes se inspiraron en la “biblia” de la ciencia de datos escrita por Wickham y Grolemund (2017).\n\n\n\nPandas es una librería para Python que está diseñada para realizar tareas relacionadas con la lectura, edición, y manipulación de datos estructurados.\nLas siguientes seis tablas contienen exactamente la misma información pero dicha info está dispuesta de manera diferente.\n\nimport pandas as pd\nbase_url = \"https://github.com/byuidatascience/data4python4ds/raw/master/data-raw/\"\ntable1 = pd.read_csv(\"{}table1/table1.csv\".format(base_url))\ntable2 = pd.read_csv(\"{}table2/table2.csv\".format(base_url))\ntable3 = pd.read_csv(\"{}table3/table3.csv\".format(base_url))\ntable4a = pd.read_csv(\"{}table4a/table4a.csv\".format(base_url))\ntable4b = pd.read_csv(\"{}table4b/table4b.csv\".format(base_url))\ntable5 = pd.read_csv(\"{}table5/table5.csv\".format(base_url), dtype = 'object')\n\nLa Tabla 1 (table1) viene así\n\ntable1\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\n0\nAfghanistan\n1999\n745\n19987071\n\n\n1\nAfghanistan\n2000\n2666\n20595360\n\n\n2\nBrazil\n1999\n37737\n172006362\n\n\n3\nBrazil\n2000\n80488\n174504898\n\n\n4\nChina\n1999\n212258\n1272915272\n\n\n5\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\nLa Tabla 2 (table2) tiene esta apariencia\n\ntable2\n\n\n\n\n\n\n\n\ncountry\nyear\ntype\ncount\n\n\n\n\n0\nAfghanistan\n1999\ncases\n745\n\n\n1\nAfghanistan\n1999\npopulation\n19987071\n\n\n2\nAfghanistan\n2000\ncases\n2666\n\n\n3\nAfghanistan\n2000\npopulation\n20595360\n\n\n4\nBrazil\n1999\ncases\n37737\n\n\n5\nBrazil\n1999\npopulation\n172006362\n\n\n6\nBrazil\n2000\ncases\n80488\n\n\n7\nBrazil\n2000\npopulation\n174504898\n\n\n8\nChina\n1999\ncases\n212258\n\n\n9\nChina\n1999\npopulation\n1272915272\n\n\n10\nChina\n2000\ncases\n213766\n\n\n11\nChina\n2000\npopulation\n1280428583\n\n\n\n\n\n\n\nLa Tabla 3 (table3) es algo distinta\n\ntable3\n\n\n\n\n\n\n\n\ncountry\nyear\nrate\n\n\n\n\n0\nAfghanistan\n1999\n745/19987071\n\n\n1\nAfghanistan\n2000\n2666/20595360\n\n\n2\nBrazil\n1999\n37737/172006362\n\n\n3\nBrazil\n2000\n80488/174504898\n\n\n4\nChina\n1999\n212258/1272915272\n\n\n5\nChina\n2000\n213766/1280428583\n\n\n\n\n\n\n\nLa tabla 4a (table4a) también es algo diferente\n\ntable4a\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\n0\nAfghanistan\n745\n2666\n\n\n1\nBrazil\n37737\n80488\n\n\n2\nChina\n212258\n213766\n\n\n\n\n\n\n\nY lo mismo podemos afirmar de la tabla 4b\n\ntable4b\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\n0\nAfghanistan\n19987071\n20595360\n\n\n1\nBrazil\n172006362\n174504898\n\n\n2\nChina\n1272915272\n1280428583\n\n\n\n\n\n\n\ny de la tabla 5\n\ntable5\n\n\n\n\n\n\n\n\ncountry\ncentury\nyear\nrate\n\n\n\n\n0\nAfghanistan\n19\n99\n745/19987071\n\n\n1\nAfghanistan\n20\n00\n2666/20595360\n\n\n2\nBrazil\n19\n99\n37737/172006362\n\n\n3\nBrazil\n20\n00\n80488/174504898\n\n\n4\nChina\n19\n99\n212258/1272915272\n\n\n5\nChina\n20\n00\n213766/1280428583\n\n\n\n\n\n\n\nLa recomendación estándar para analizar datos estructurados es que cada variable debe ocupar una columna, cada observación debe ocupar una fila o renglón, y los valores de cada observación deben estar en cada celda, tal como aparece en la siguiente imágen.\n\n\n\n\n\nEstas tres reglas están interrelacionadas porque es imposible satisfacer solo dos de las tres. Esa interrelación conduce a un conjunto aún más simple de instrucciones prácticas:\nColoque cada conjunto de datos en un objeto de tipo tibble. Coloque cada variable en una columna.\nEn este ejemplo, solo la tabla 1 está ordenada. Es la única representación donde cada columna es una variable.\n¿Por qué es importante tener los datos ordenados?\nLa ventaja general es tener una forma consistente de almacenar datos. Si tiene una estructura de datos consistente, es más fácil aprender las herramientas que funcionan con ella porque tienen una uniformidad subyacente. La ventaja específica en colocar variables en columnas es que permite que la naturaleza vectorizada de pandas y NumPy brille.\nLas librerías “altair” y “Pandas” funcionan bien con datos ordenados. Aquí hay un par de pequeños ejemplos que muestran cómo podría trabajar con la tabla 1.\n\nimport altair as alt\ntable1.assign(\n    rate = lambda x: x.cases / x.population * 1000\n)\n\n(table1.\n  groupby('year').\n  agg(n = ('cases', 'sum')).\n  reset_index())\n  \nbase_chart = (alt.Chart(table1).\n  encode(alt.X('year'), alt.Y('cases'), detail = 'country'))\n\nchart = base_chart.mark_line() + base_chart.encode(color = 'country').mark_circle()\n\nchart\n\n/home/jcc/anaconda3/lib/python3.12/site-packages/altair/utils/core.py:395: FutureWarning:\n\nthe convert_dtype parameter is deprecated and will be removed in a future version.  Do ``ser.astype(object).apply()`` instead if you want ``convert_dtype=False``."
  },
  {
    "objectID": "Py4DS.html#organización-de-datos-con-pandas",
    "href": "Py4DS.html#organización-de-datos-con-pandas",
    "title": "Analítica de Proyectos",
    "section": "",
    "text": "Pandas es una librería para Python que está diseñada para realizar tareas relacionadas con la lectura, edición, y manipulación de datos estructurados.\nLas siguientes seis tablas contienen exactamente la misma información pero dicha info está dispuesta de manera diferente.\n\nimport pandas as pd\nbase_url = \"https://github.com/byuidatascience/data4python4ds/raw/master/data-raw/\"\ntable1 = pd.read_csv(\"{}table1/table1.csv\".format(base_url))\ntable2 = pd.read_csv(\"{}table2/table2.csv\".format(base_url))\ntable3 = pd.read_csv(\"{}table3/table3.csv\".format(base_url))\ntable4a = pd.read_csv(\"{}table4a/table4a.csv\".format(base_url))\ntable4b = pd.read_csv(\"{}table4b/table4b.csv\".format(base_url))\ntable5 = pd.read_csv(\"{}table5/table5.csv\".format(base_url), dtype = 'object')\n\nLa Tabla 1 (table1) viene así\n\ntable1\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\n0\nAfghanistan\n1999\n745\n19987071\n\n\n1\nAfghanistan\n2000\n2666\n20595360\n\n\n2\nBrazil\n1999\n37737\n172006362\n\n\n3\nBrazil\n2000\n80488\n174504898\n\n\n4\nChina\n1999\n212258\n1272915272\n\n\n5\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\nLa Tabla 2 (table2) tiene esta apariencia\n\ntable2\n\n\n\n\n\n\n\n\ncountry\nyear\ntype\ncount\n\n\n\n\n0\nAfghanistan\n1999\ncases\n745\n\n\n1\nAfghanistan\n1999\npopulation\n19987071\n\n\n2\nAfghanistan\n2000\ncases\n2666\n\n\n3\nAfghanistan\n2000\npopulation\n20595360\n\n\n4\nBrazil\n1999\ncases\n37737\n\n\n5\nBrazil\n1999\npopulation\n172006362\n\n\n6\nBrazil\n2000\ncases\n80488\n\n\n7\nBrazil\n2000\npopulation\n174504898\n\n\n8\nChina\n1999\ncases\n212258\n\n\n9\nChina\n1999\npopulation\n1272915272\n\n\n10\nChina\n2000\ncases\n213766\n\n\n11\nChina\n2000\npopulation\n1280428583\n\n\n\n\n\n\n\nLa Tabla 3 (table3) es algo distinta\n\ntable3\n\n\n\n\n\n\n\n\ncountry\nyear\nrate\n\n\n\n\n0\nAfghanistan\n1999\n745/19987071\n\n\n1\nAfghanistan\n2000\n2666/20595360\n\n\n2\nBrazil\n1999\n37737/172006362\n\n\n3\nBrazil\n2000\n80488/174504898\n\n\n4\nChina\n1999\n212258/1272915272\n\n\n5\nChina\n2000\n213766/1280428583\n\n\n\n\n\n\n\nLa tabla 4a (table4a) también es algo diferente\n\ntable4a\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\n0\nAfghanistan\n745\n2666\n\n\n1\nBrazil\n37737\n80488\n\n\n2\nChina\n212258\n213766\n\n\n\n\n\n\n\nY lo mismo podemos afirmar de la tabla 4b\n\ntable4b\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\n0\nAfghanistan\n19987071\n20595360\n\n\n1\nBrazil\n172006362\n174504898\n\n\n2\nChina\n1272915272\n1280428583\n\n\n\n\n\n\n\ny de la tabla 5\n\ntable5\n\n\n\n\n\n\n\n\ncountry\ncentury\nyear\nrate\n\n\n\n\n0\nAfghanistan\n19\n99\n745/19987071\n\n\n1\nAfghanistan\n20\n00\n2666/20595360\n\n\n2\nBrazil\n19\n99\n37737/172006362\n\n\n3\nBrazil\n20\n00\n80488/174504898\n\n\n4\nChina\n19\n99\n212258/1272915272\n\n\n5\nChina\n20\n00\n213766/1280428583\n\n\n\n\n\n\n\nLa recomendación estándar para analizar datos estructurados es que cada variable debe ocupar una columna, cada observación debe ocupar una fila o renglón, y los valores de cada observación deben estar en cada celda, tal como aparece en la siguiente imágen.\n\n\n\n\n\nEstas tres reglas están interrelacionadas porque es imposible satisfacer solo dos de las tres. Esa interrelación conduce a un conjunto aún más simple de instrucciones prácticas:\nColoque cada conjunto de datos en un objeto de tipo tibble. Coloque cada variable en una columna.\nEn este ejemplo, solo la tabla 1 está ordenada. Es la única representación donde cada columna es una variable.\n¿Por qué es importante tener los datos ordenados?\nLa ventaja general es tener una forma consistente de almacenar datos. Si tiene una estructura de datos consistente, es más fácil aprender las herramientas que funcionan con ella porque tienen una uniformidad subyacente. La ventaja específica en colocar variables en columnas es que permite que la naturaleza vectorizada de pandas y NumPy brille.\nLas librerías “altair” y “Pandas” funcionan bien con datos ordenados. Aquí hay un par de pequeños ejemplos que muestran cómo podría trabajar con la tabla 1.\n\nimport altair as alt\ntable1.assign(\n    rate = lambda x: x.cases / x.population * 1000\n)\n\n(table1.\n  groupby('year').\n  agg(n = ('cases', 'sum')).\n  reset_index())\n  \nbase_chart = (alt.Chart(table1).\n  encode(alt.X('year'), alt.Y('cases'), detail = 'country'))\n\nchart = base_chart.mark_line() + base_chart.encode(color = 'country').mark_circle()\n\nchart\n\n/home/jcc/anaconda3/lib/python3.12/site-packages/altair/utils/core.py:395: FutureWarning:\n\nthe convert_dtype parameter is deprecated and will be removed in a future version.  Do ``ser.astype(object).apply()`` instead if you want ``convert_dtype=False``."
  }
]