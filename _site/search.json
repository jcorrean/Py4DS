[
  {
    "objectID": "Py4DS.html",
    "href": "Py4DS.html",
    "title": "Analítica de Proyectos",
    "section": "",
    "text": "Hay varias razones que nos obligan a considerar otras opciones más allá de Excel y de Microsoft Project que suelen ser las herramientas más populares para la gestión de proyectos.\n\nExcel es limitado a la hora abrir archivos con datos que están en el orden de los millones de filas o columnas. (Excel no sirve para hacer Big Data)\nMicrosoft Project no nos permite saber los pequeños cambios que pueden ocurrir en cada uno de los archivos asociados al desarrollo del proyecto. Con Python y R, estos cambios pueden gestionarse de mánera ágil a través de GitHub.\nNi Excel ni Project son útiles para analizar “datos no estructurados” tales como colecciones de documentos, fotos, videos, o audios. En cambio los datos no estructurados son analizables con Python y R de una forma más ágil.\nEl análisis de datos no estructurados es la base fundamental de herramientas como el aprendizaje automático (conocido en inglés como Machine Learning). Veamos algunas funcionalidades básicas en las llamadas ciencias de datos para entender cómo funciona Python. Una cruda realidad es que las personas encargadas de recolectar datos no son especialistas en estadística y por ello no suelen guardar los datos de una manera que sean directamente usables para fines analíticos. Parte de lo que veremos en las próximas subsecciones está tomado del libro de texto de Hathaway y Larson (2021) quienes se inspiraron en la “biblia” de la ciencia de datos escrita por Wickham y Grolemund (2017).\n\n\n\nPandas es una librería para Python que está diseñada para realizar tareas relacionadas con la lectura, edición, y manipulación de datos estructurados.\nLo primero que vamos a hacer es un ejercicio de big data, descomprimiendo un total de 22 archivos comprimidos con data de vuelos internacionales. Parte de lo que veremos acá está adaptado del blog de Marc Garcia (2022).\n\nimport bz2\nfrom pathlib import Path\n\ndef decompress_bz2_files(directory_path):\n    \"\"\"Decompresses .bz2 files only if the corresponding CSV files don't exist.\n\n    Args:\n        directory_path (str): Path to the directory containing .bz2 files.\n    \"\"\"\n\n    for file in Path(directory_path).rglob('*.bz2'):\n        output_file = str(file).replace('.bz2', '')\n\n        # Check if the output CSV file already exists\n        if not Path(output_file).exists():\n            with bz2.open(file, 'rb') as bz_file:\n                decompressed_data = bz_file.read()\n\n            with open(output_file, 'wb') as out_file:\n                out_file.write(decompressed_data)\n            print(f\"Decompressed: {file}\")\n        else:\n            print(f\"CSV file already exists: {output_file}\")\n\n# Replace 'your_directory_path' with the actual path to your .bz2 files\ndirectory_path = '/home/jcc/dataverse_files'\ndecompress_bz2_files(directory_path)\n\nCSV file already exists: /home/jcc/dataverse_files/2007.csv\nCSV file already exists: /home/jcc/dataverse_files/1995.csv\nCSV file already exists: /home/jcc/dataverse_files/1987.csv\nCSV file already exists: /home/jcc/dataverse_files/1996.csv\nCSV file already exists: /home/jcc/dataverse_files/2005.csv\nCSV file already exists: /home/jcc/dataverse_files/2006.csv\nCSV file already exists: /home/jcc/dataverse_files/1988.csv\nCSV file already exists: /home/jcc/dataverse_files/2002.csv\nCSV file already exists: /home/jcc/dataverse_files/2001.csv\nCSV file already exists: /home/jcc/dataverse_files/1992.csv\nCSV file already exists: /home/jcc/dataverse_files/2004.csv\nCSV file already exists: /home/jcc/dataverse_files/1991.csv\nCSV file already exists: /home/jcc/dataverse_files/1993.csv\nCSV file already exists: /home/jcc/dataverse_files/1994.csv\nCSV file already exists: /home/jcc/dataverse_files/1998.csv\nCSV file already exists: /home/jcc/dataverse_files/1997.csv\nCSV file already exists: /home/jcc/dataverse_files/1999.csv\nCSV file already exists: /home/jcc/dataverse_files/1989.csv\nCSV file already exists: /home/jcc/dataverse_files/2000.csv\nCSV file already exists: /home/jcc/dataverse_files/2003.csv\nCSV file already exists: /home/jcc/dataverse_files/2008.csv\nCSV file already exists: /home/jcc/dataverse_files/1990.csv\n\n\nUna vez realizado lo anterior, ahora pasamos a abrir la data\n\nimport pandas\n\nLOAD_COLS = 'Origin', 'Year', 'Month', 'DayofMonth', 'CRSDepTime', 'DepTime'\n\ndf = pandas.concat((pandas.read_csv(f'/home/jcc/dataverse_files/{fname}.csv',\n                                    usecols=LOAD_COLS,\n                                    encoding_errors='ignore',\n                                    dtype={'Origin': 'category',\n                                           'Year': 'uint16',\n                                           'Month': 'uint8',\n                                           'DayofMonth': 'uint8',\n                                           'CRSDepTime': 'uint16',\n                                           'DepTime': 'UInt16'})\n                    for fname\n                    in range(1987, 2009)),\n                   ignore_index=True)\n\ndate = pandas.to_datetime(df[['Year', 'Month', 'DayofMonth']].rename(columns={'DayofMonth': 'Day'}))\n\ndf['scheduled_dep'] = date + pandas.to_timedelta((df['CRSDepTime'] // 100) * 60 + (df['CRSDepTime'] % 100),\n                                                 unit='minutes')\ndf['actual_dep'] = date + pandas.to_timedelta((df['DepTime'] // 100) * 60 + (df['DepTime'] % 100),\n                                            unit='minutes')\n\ndel date\ndf = df[['Origin', 'scheduled_dep', 'actual_dep']]\n\ndf['delay'] = (df['actual_dep'] - df['scheduled_dep']).dt.total_seconds() / 60 / 60\n\ndf['delay'] = df['delay'].where(df['delay'] &gt; - 2, 24 - df['delay'])\n\ndf.head(5)\nfilas = len(df)\nprint(f'La base de datos tiene un total de {filas} filas.')\n\nLa base de datos tiene un total de 118914458 filas."
  },
  {
    "objectID": "Py4DS.html#organización-de-datos-con-pandas",
    "href": "Py4DS.html#organización-de-datos-con-pandas",
    "title": "Analítica de Proyectos",
    "section": "",
    "text": "Pandas es una librería para Python que está diseñada para realizar tareas relacionadas con la lectura, edición, y manipulación de datos estructurados.\nLo primero que vamos a hacer es un ejercicio de big data, descomprimiendo un total de 22 archivos comprimidos con data de vuelos internacionales. Parte de lo que veremos acá está adaptado del blog de Marc Garcia (2022).\n\nimport bz2\nfrom pathlib import Path\n\ndef decompress_bz2_files(directory_path):\n    \"\"\"Decompresses .bz2 files only if the corresponding CSV files don't exist.\n\n    Args:\n        directory_path (str): Path to the directory containing .bz2 files.\n    \"\"\"\n\n    for file in Path(directory_path).rglob('*.bz2'):\n        output_file = str(file).replace('.bz2', '')\n\n        # Check if the output CSV file already exists\n        if not Path(output_file).exists():\n            with bz2.open(file, 'rb') as bz_file:\n                decompressed_data = bz_file.read()\n\n            with open(output_file, 'wb') as out_file:\n                out_file.write(decompressed_data)\n            print(f\"Decompressed: {file}\")\n        else:\n            print(f\"CSV file already exists: {output_file}\")\n\n# Replace 'your_directory_path' with the actual path to your .bz2 files\ndirectory_path = '/home/jcc/dataverse_files'\ndecompress_bz2_files(directory_path)\n\nCSV file already exists: /home/jcc/dataverse_files/2007.csv\nCSV file already exists: /home/jcc/dataverse_files/1995.csv\nCSV file already exists: /home/jcc/dataverse_files/1987.csv\nCSV file already exists: /home/jcc/dataverse_files/1996.csv\nCSV file already exists: /home/jcc/dataverse_files/2005.csv\nCSV file already exists: /home/jcc/dataverse_files/2006.csv\nCSV file already exists: /home/jcc/dataverse_files/1988.csv\nCSV file already exists: /home/jcc/dataverse_files/2002.csv\nCSV file already exists: /home/jcc/dataverse_files/2001.csv\nCSV file already exists: /home/jcc/dataverse_files/1992.csv\nCSV file already exists: /home/jcc/dataverse_files/2004.csv\nCSV file already exists: /home/jcc/dataverse_files/1991.csv\nCSV file already exists: /home/jcc/dataverse_files/1993.csv\nCSV file already exists: /home/jcc/dataverse_files/1994.csv\nCSV file already exists: /home/jcc/dataverse_files/1998.csv\nCSV file already exists: /home/jcc/dataverse_files/1997.csv\nCSV file already exists: /home/jcc/dataverse_files/1999.csv\nCSV file already exists: /home/jcc/dataverse_files/1989.csv\nCSV file already exists: /home/jcc/dataverse_files/2000.csv\nCSV file already exists: /home/jcc/dataverse_files/2003.csv\nCSV file already exists: /home/jcc/dataverse_files/2008.csv\nCSV file already exists: /home/jcc/dataverse_files/1990.csv\n\n\nUna vez realizado lo anterior, ahora pasamos a abrir la data\n\nimport pandas\n\nLOAD_COLS = 'Origin', 'Year', 'Month', 'DayofMonth', 'CRSDepTime', 'DepTime'\n\ndf = pandas.concat((pandas.read_csv(f'/home/jcc/dataverse_files/{fname}.csv',\n                                    usecols=LOAD_COLS,\n                                    encoding_errors='ignore',\n                                    dtype={'Origin': 'category',\n                                           'Year': 'uint16',\n                                           'Month': 'uint8',\n                                           'DayofMonth': 'uint8',\n                                           'CRSDepTime': 'uint16',\n                                           'DepTime': 'UInt16'})\n                    for fname\n                    in range(1987, 2009)),\n                   ignore_index=True)\n\ndate = pandas.to_datetime(df[['Year', 'Month', 'DayofMonth']].rename(columns={'DayofMonth': 'Day'}))\n\ndf['scheduled_dep'] = date + pandas.to_timedelta((df['CRSDepTime'] // 100) * 60 + (df['CRSDepTime'] % 100),\n                                                 unit='minutes')\ndf['actual_dep'] = date + pandas.to_timedelta((df['DepTime'] // 100) * 60 + (df['DepTime'] % 100),\n                                            unit='minutes')\n\ndel date\ndf = df[['Origin', 'scheduled_dep', 'actual_dep']]\n\ndf['delay'] = (df['actual_dep'] - df['scheduled_dep']).dt.total_seconds() / 60 / 60\n\ndf['delay'] = df['delay'].where(df['delay'] &gt; - 2, 24 - df['delay'])\n\ndf.head(5)\nfilas = len(df)\nprint(f'La base de datos tiene un total de {filas} filas.')\n\nLa base de datos tiene un total de 118914458 filas."
  }
]